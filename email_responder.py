import email
import engine
import imaplib
import json
import os
import pprint
import re
import smtplib
import sys
import yaml
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

"""

    Look through a google INBOX and for each email message matching
    a pattern containing a lava job id, run lava job id through engine.py
    and reply to the email with the results.

    Once a given lava job id has been notified, it will not notify again due to
    an entry in .email_cache.json.

    Example Usage:
    EMAIL_ADDRESS=dan.rue@linaro.org EMAIL_PASSWORD=XXX python3 email_responder.py

    Example cron:
    */5 * * * * cd /home/drue/src/lava-triager && EMAIL_ADDRESS=dan.rue@linaro.org EMAIL_PASSWORD=XXX python3 email_responder.py >> /home/drue/lava-triager.log 2>&1

"""

class jsonCacher(object):
    def __init__(self, cache_file=".email_cache.json"):
        self.cache_file = cache_file
        if os.path.exists(self.cache_file):
            self._load()
        else:
            self.json_cache = []

    def _load(self):
        with open(self.cache_file) as data:
            self.json_cache = json.load(data)

    def _save(self):
        with open(self.cache_file, 'w') as outfile:
            json.dump(self.json_cache, outfile)

    def cache_job(self, job_id):
        if job_id in self.json_cache:
            return
        self.json_cache.append(job_id)
        self._save()

    def has(self, job_id):
        return job_id in self.json_cache

cache = jsonCacher()
mail = imaplib.IMAP4_SSL('imap.gmail.com')
mail.login(os.environ.get('EMAIL_ADDRESS'), os.environ.get('EMAIL_PASSWORD'))
mail.list()
mail.select("INBOX")
result, data = mail.uid('search', None, 'FROM', '"qa-reports@linaro.org"',
                                        'SUBJECT', 'TestJob',
                                        'SUBJECT', 'failed',
                                        'SUBJECT', 'status',
                                        'SUBJECT', 'Incomplete',
                                        )

for uid in data[0].split():

    result, data = mail.uid('fetch', uid, '(RFC822)')
    raw_email = data[0][1]

    email_message = email.message_from_string(raw_email.decode("utf-8"))

    m = re.search('TestJob (\d+) ', email_message['Subject'])
    lava_job_id = m.group(1)

    if cache.has(lava_job_id):
        print("Lava job already processed: {}".format(lava_job_id))
        continue

    _, job_results = engine.main(lava_job_id)
    if not job_results:
        # We could cache failed jobs so they don't rerun
        # But, this way if the rules are updated, it will re-try and send
        # a notification.
        # cache.cache_job(lava_job_id)
        print("No results found for job id {}".format(lava_job_id), file=sys.stderr)
        continue

    response_content = ""
    for result in job_results:
        response_content += result['description']

    response_details = yaml.dump(job_results)

    response_body = """
On {}, {} said:
{}

{}

---

Signature(s) matched:
{}

Response auto-generated by https://github.com/danrue/lava-triager
""".format(
        email_message['Date'],
        email_message['From'],
        re.sub('^', '> ', email_message.get_payload(), 0, re.MULTILINE),
        response_content,
        response_details
        )

    response_from = "Dan Rue <dan.rue@linaro.org>"
    #response_to = "Dan Rue <dan.rue@linaro.org>" # Use for testing
    response_to = email_message['To']

    response = MIMEMultipart()
    response['From'] = response_from
    response['To'] = response_to
    response['Subject'] = "Re: {}".format(email_message['Subject'])
    response['In-Reply-To'] = email_message['Message-ID']
    response['References'] = email_message['Message-ID']
    response.attach(MIMEText(response_body, 'plain'))

    server = smtplib.SMTP('smtp.gmail.com', 587)
    server.starttls()
    server.login(os.environ.get('EMAIL_ADDRESS'), os.environ.get('EMAIL_PASSWORD'))
    server.sendmail(response_from, response_to, response.as_string())
    server.quit()
    print("Lava job processed: {}".format(lava_job_id))
    cache.cache_job(lava_job_id)

