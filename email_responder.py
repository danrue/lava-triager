import email
import email.utils
import engine
import imaplib
import json
import os
import pprint
import re
import smtplib
import sys
import yaml
from email.mime.text import MIMEText
from email.utils import parseaddr

"""

    Look through a google INBOX and for each email message matching
    a pattern containing a lava job id, run lava job id through engine.py
    and reply to the email with the results.

    Once a given lava job id has been notified, it will not notify again due to
    an entry in .email_cache.json.

    Example Usage:
    EMAIL_ADDRESS=dan.rue@linaro.org EMAIL_PASSWORD=XXX python3 email_responder.py

    Example cron:
    */5 * * * * cd /home/drue/src/lava-triager && EMAIL_ADDRESS=dan.rue@linaro.org EMAIL_PASSWORD=XXX python3 email_responder.py >> /home/drue/lava-triager.log 2>&1

"""

class jsonCacher(object):
    def __init__(self, cache_file=".email_cache.json"):
        self.cache_file = cache_file
        if os.path.exists(self.cache_file):
            self._load()
        else:
            self.json_cache = []

    def _load(self):
        with open(self.cache_file) as data:
            self.json_cache = json.load(data)

    def _save(self):
        with open(self.cache_file, 'w') as outfile:
            json.dump(self.json_cache, outfile)

    def cache_job(self, job_id):
        if job_id in self.json_cache:
            return
        self.json_cache.append(job_id)
        self._save()

    def has(self, job_id):
        return job_id in self.json_cache

cache = jsonCacher()
mail = imaplib.IMAP4_SSL('imap.gmail.com')
mail.login(os.environ.get('EMAIL_ADDRESS'), os.environ.get('EMAIL_PASSWORD'))
mail.list()
mail.select("INBOX")
result, data = mail.uid('search', None, 'FROM', '"qa-reports@linaro.org"',
                                        'SUBJECT', 'TestJob',
                                        'SUBJECT', 'lkft',
                                        'SUBJECT', 'Incomplete',
                                        )

for uid in data[0].split():

    result, data = mail.uid('fetch', uid, '(RFC822)')
    raw_email = data[0][1]

    email_message = email.message_from_string(raw_email.decode("utf-8"))

    m = re.search('TestJob (\d+): ', email_message['Subject'])
    lava_job_id = m.group(1)

    if cache.has(lava_job_id):
        print("Lava job already processed: {}".format(lava_job_id))
        continue

    _, job_results = engine.main(lava_job_id)
    if not job_results:
        # We could cache failed jobs so they don't rerun
        # But, this way if the rules are updated, it will re-try and send
        # a notification.
        # cache.cache_job(lava_job_id)
        print("No results found for job id {}".format(lava_job_id), file=sys.stderr)
        continue

    response_content = ""
    for result in job_results:
        response_content += result['description']

    job_results_no_description = []
    for result in job_results:
        del result['description']
        job_results_no_description.append(result)
    response_details = yaml.dump(job_results_no_description)

    response_body = """
On {}, {} said:
{}

{}

---

Signature(s) matched:
{}

Response auto-generated by https://github.com/danrue/lava-triager
""".format(
        email_message['Date'],
        email_message['From'],
        re.sub('^', '> ', email_message.get_payload(), 0, re.MULTILINE),
        response_content,
        response_details
        )

    response_from = "Dan Rue <dan.rue@linaro.org>"
    response_to = email_message['To']
    response_to_list = []
    # This little bit of horribleness brought to you by python, rfc 822, and
    # crooked congressmen everywhere.
    # sendmail() below needs a list of addresses. Extract them from 'To'.
    for line in email_message.get_all('To')[0].split('\r\n'):
        for addy in line.split(','):
            new_addy = parseaddr(addy)[1]
            if new_addy not in response_to_list and len(new_addy)>0:
                response_to_list.append(new_addy)
    #response_to_list = ["drue@therub.org"] # Use for testing

    response = MIMEText(response_body)
    response['From'] = response_from
    response['To'] = response_to
    response['Subject'] = "Re: {}".format(email_message['Subject'])
    response['In-Reply-To'] = email_message['Message-ID']
    response['References'] = email_message['Message-ID']

    server = smtplib.SMTP('smtp.gmail.com', 587)
    server.starttls()
    server.login(os.environ.get('EMAIL_ADDRESS'), os.environ.get('EMAIL_PASSWORD'))
    server.sendmail(response_from, response_to_list, response.as_string())
    server.quit()
    print("Lava job processed: {}".format(lava_job_id))
    cache.cache_job(lava_job_id)

